#!/bin/bash -eu
#
# Notes: Things to implement
#
# - [x] Use fzf, bat to render and preview documents
#       Sanity check they're installed as well
# - [x] Query implementation
# - [x] New implementation: include templates
# - [x] Edit implementation: show related files
# - [x] Grouped rendering for a CLI focalgoard based on queries
# - [x] Pomodoro implementation
# - [ ] Publish implementation
# - [ ] Utility language to expand time

if [[ -n "${TDX_DEBUG:-}" ]]; then
    set -x
fi

########################################################################
# Constants
########################################################################
CUR_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
readonly CUR_DIR
readonly TDX_MDF="${TDX_MDF:-"$CUR_DIR/markdown_files/zig-out/lib/libmarkdown_files.so"}"
export SELF="$0"


########################################################################
# Utilities
########################################################################
function err {
    echo -e "\033[91m $* \033[0m" >&2
}

function check_dep {
    if ! command -v "$1" &> /dev/null; then
	err "Couldn't find $1 in \$PATH: please make sure it's installed!"
	exit 1
    fi
}

function check_lib {
    if [[ ! -f "$1" ]]; then
	err "Couldn't find $1: please make sure it's available!"
	exit 1
    fi
}


########################################################################
# Implementation
########################################################################

function print_usage {
    echo "$(basename "${BASH_SOURCE[0]}") usage:"
    echo "  n, new [template=note,task,bookmark,reminder,pomodoro,*]"
    echo "  e, edit <path>"
    echo "  q, query [where clause]"
    echo "  j, journal"
    echo "  p, pomodoro"
    echo "  s, sql"
    echo "  b, board [group by] [filter]"
    echo "  t, tasks [collection]"
    exit 1
}

function new {
    local template="${1:-}"
    if [[ -n "$template" ]]; then
	shift
    fi

    local path
    path="$(date +%Y/%m/%d)"

    local filename
    filename="$(date +%s).md"

    mkdir -p "$path"
    local full_path="$path/$filename"

    case "$template" in
	n|note)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
collection: ${2:-}
tags:
what: note
publish: true
---

EOF
	    ;;
	t|task)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
collection: ${2:-}
tags:
what: task
when: someday    # today, tomorrow, week, month, quarter, someday
status:          # blocked, active, done
deadline:
---

EOF
	    ;;
	b|bookmark)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
url: ${2:-}
collection: ${3:-}
tags:
what: bookmark
source:
publish: true
---

EOF
	    ;;
	r|reminder)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
when: ${2:-}
collection: ${3:-}
what: reminder
---

EOF
	    ;;
	p|pomo|pomodoro)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
collection: ${2:-}
what: pomodoro
---

EOF
	    ;;
	*)
	    cat <<EOF >"$full_path"
---
title: ${1:-}
collection: ${2:-}
tags:
what: $template
---

EOF
    esac
    "$EDITOR" "$full_path"

    if  [[ ! -s "$full_path" ]]; then
	rm "$full_path"
    fi
}

function query {
    local location
    location=$(pwd)

    local sql_query
    sql_query=$(cat <<EOF
SELECT
  substr(path, length('$location') + 2),
  ' / ',
  mdf_front_matter(path, 'title'),
  ' ',
  mdf_front_matter(path, 'collection'),
  ' ',
  mdf_front_matter(path, 'what'),
  ' ',
  mdf_front_matter(path, 'tags')
FROM
  markdown_files
WHERE
  path LIKE '%.md'
  AND path NOT LIKE '%.git'
  ${1:+AND $1}
ORDER BY
  mtime_s DESC,
  path ASC
EOF
	  );

    command=$(cat <<EOF
/usr/bin/env \
  sqlite3 -list -separator "" :memory: \
  ".load $TDX_MDF sqlite3_markdown_files_init" \
  "$sql_query"
EOF
			  );

    (
	export FZF_DEFAULT_COMMAND="$command";
	fzf --header "TERMinal inDEX    [$(pwd)]    [$(date +%F)]" \
	--header-first \
	--preview 'file=$(echo {1}); bat --theme=zenburn --color=always --style=plain "$file"' \
	--preview-window 'bottom:border-sharp:wrap' \
	--layout reverse \
	--bind 'ctrl-r:reload(eval "$FZF_DEFAULT_COMMAND")' \
	--bind 'enter:execute(eval "$SELF e {1}")+reload(eval "$FZF_DEFAULT_COMMAND")' \
	--bind 'ctrl-n:execute(eval "$SELF n")' \
	--info inline-right
    )

}

function edit {
    local path="$1"

    local parent_dir
    parent_dir="$(dirname "$path")"
    mkdir -p "$parent_dir"

    local final_path

    if [[ "$path" == *".md" ]]; then
	final_path="$path"
    else
	final_path="${path}.md"
    fi

    if [[ ! -f "$final_path" ]]; then
	cat <<EOF >"$final_path"
---
title:
---
EOF
    fi

    local rel_path
    rel_path="$(realpath -s --relative-to="$(pwd)" "$final_path")"
    local collection="${rel_path%.md}"

    local related
    related="$(mktemp "related-$(echo "$collection" | tr '/' '_')-XXX.md")"

    local query
    query="$(cat <<EOF
SELECT
  '=== '||path||' ===',
  mdf_contents(path) AS file
FROM
  markdown_files
WHERE
  basename LIKE '%.md'
  AND path NOT LIKE '%.git%'
  AND mdf_front_matter(path, 'collection') = '$collection'
ORDER BY
  mtime_s DESC,
  path ASC;
EOF
)"

    "$SELF" sql "-list" '.separator \n' "$query" \
	    | tr -d '\r' > "$related";
    chmod -w "$related"

    if [[ ! -s "$related" ]]; then
	rm -f "$related"
	"$EDITOR" "$final_path"
    else
	"$EDITOR" "$final_path" "$related"
    fi

    if [[ ! -s "$final_path" ]]; then
	rm "$final_path"
    fi

    rm -f "$related"
}

function journal {
    local path
    path="$(date +%Y/%m/%d).md"

    local parent_dir
    parent_dir="$(dirname "$path")"
    mkdir -p "$parent_dir"

    if [[ ! -f "$path" ]]; then
	cat <<EOF >"$path"
---
title: $(date +%F)
---
EOF
    fi

    local related
    related="$(mktemp "related-$(date +%F)-XXX.md")"

    local location
    location=$(pwd)

    local query
    query="$(cat <<EOF
SELECT
  '=== '||path||' ===',
  mdf_contents(path) AS file
FROM
  markdown_files
WHERE
  basename LIKE '%.md'
  AND path NOT LIKE '%.git%'
  AND SUBSTR(path, length('$location') + 2) LIKE '${path%.md}%'
ORDER BY
  mdf_front_matter(path, 'what') ASC,
  mtime_s DESC,
  path ASC;
EOF
)"

    "$SELF" sql "-list" '.separator \n' "$query" \
	    | tr -d '\r' > "$related";
    chmod -w "$related"

    if [[ ! -s "$related" ]]; then
	rm -f "$related"
	"$EDITOR" "$path"
    else
	"$EDITOR" "$path" "$related"
    fi

    if [[ ! -s "$path" ]]; then
	rm "$path"
    fi

    rm -f "$related"
}

function pomodoro {
    while true; do
	echo -ne "\033[91mPomodoro goal?\033[0m      : "
	local purpose
	read -r purpose

	local collection
	echo -ne "\033[91mAdd to collection?\033[0m  : "
	read -r collection

	local end_time
	end_time="$(date -d "+25 minutes")"

	local end_timestamp
	end_timestamp="$(date -d "$end_time" +%s)"

	echo -e "\n> Pomodoro will end at ${end_time}"
	echo -n "> "
	while (( $(date +%s) < end_timestamp )); do
	    sleep 60
	    echo -n "."
	done
	echo -e '\a'

	$SELF new pomodoro "$purpose" "$collection"
	echo -e "> Recorded.\n"

	end_time="$(date -d "+5 minutes")"
	end_timestamp="$(date -d "$end_time" +%s)"
	echo "> Break will end at ${end_time}"
	echo -n "> "
	while (( $(date +%s) < end_timestamp )); do
	    sleep 60
	    echo -n "."
	done
	echo -e "\a\n\n"
    done
}

function sql {
    exec /usr/bin/env sqlite3 :memory: -cmd ".load $TDX_MDF sqlite3_markdown_files_init" "$@"
}

function board {
    local group_by="${1:-when}"
    local query
    query=$(cat <<EOF
SELECT
  DISTINCT(coalesce(mdf_front_matter(path, '$group_by'), 'null'))
FROM
  markdown_files
WHERE
  (
    mdf_front_matter(path, 'status') != 'done'
    OR mdf_front_matter(path, 'status') IS NULL
  )
  ${2:+AND $2}
GROUP BY 1
ORDER BY COUNT(1) DESC
EOF
)
    local vals
    vals="$("$SELF" sql "-list" "$query")"

    for val in $vals; do
	echo -e "=== ${val} ==="
	    "$SELF" sql "-list" ".separator ' '" "SELECT path, mdf_front_matter(path, 'title'), mdf_front_matter(path, 'collection'), mdf_front_matter(path, 'tags') FROM markdown_files WHERE mdf_front_matter(path, '$group_by') = '$val' AND basename LIKE '%.md' AND path NOT LIKE '%.git%' ${2:+AND $2} ORDER BY mtime_s DESC"
	echo
    done |\
	fzf --header "TERMinal inDEX    [$(pwd)]    [$(date +%F)]" \
	    --header-first \
	    --preview 'file=$(echo {1}); bat --theme=zenburn --color=always --style=plain "$file"' \
	    --preview-window 'bottom:border-sharp:wrap' \
	    --layout reverse \
	    --bind 'enter:execute(eval "$SELF e {1}")+become(eval "$SELF b $group_by")' \
	    --info inline-right
}

function tasks {
    local whens=(today week month quarter half year someday unset)

    local location
    location=$(pwd)

    for when in "${whens[@]}"; do
	local group_query
	group_query="$(cat <<EOF
SELECT
  substr(path, length('$location') + 2),
  mdf_front_matter(path, 'title'),
  mdf_front_matter(path, 'collection'),
  mdf_front_matter(path, 'tags')
FROM markdown_files
WHERE
  mdf_front_matter(path, 'when') = '$when'
  AND basename LIKE '%.md'
  AND path NOT LIKE '%.git%'
  AND COALESCE(mdf_front_matter(path, 'status'), 'unset') != 'done'
  ${1:+AND coalesce(mdf_front_matter(path, 'collection'), 'unset') = '$1'}
ORDER BY
  mtime_s DESC
EOF
	)";
	printf "=== %-72s ===\n" "$when"
	"$SELF" sql "-list" ".separator ' '" "$group_query"
	echo
    done |\
      fzf --header "TERMinal inDEX    [$(pwd)]    [$(date +%F)]" \
	  --header-first \
	  --preview 'file=$(echo {1}); [[ -f "$file" ]] && bat --theme=zenburn --color=always --style=plain "$file"' \
	  --preview-window 'bottom:border-sharp:wrap' \
	  --layout reverse \
	  --bind 'enter:become(eval "tmux display-popup -w 90% -h 90% -E $SELF e {1} && $SELF t $1")' \
	  --bind 'ctrl-n:become(eval "tmux display-popup -w 90% -h 90% -E $SELF n t && $SELF t $1")' \
	  --info inline-right

    # TODO show uncategorized
    #    local query
    #    query=$(cat <<EOF
    #SELECT
    #  DISTINCT(
    #    CASE
    #      WHEN mdf_front_matter(path, 'when') IS NULL OR mdf_front_matter(path, 'when') = ''
    #      THEN 'unset'
    #      ELSE mdf_front_matter(path, 'when')
    #    END
    #  )
    #FROM
    #  markdown_files
    #WHERE
    #  COALESCE(mdf_front_matter(path, 'status'), 'unset') != 'done'
    #GROUP BY 1
    #ORDER BY COUNT(1) DESC
    #EOF
    #)
    #    local vals
    #    vals="$("$SELF" sql "-list" "$query")"
    #    echo "$vals"
}

function main {
    check_dep fzf
    check_dep sqlite3
    check_dep bat
    check_lib "$TDX_MDF"

    if (( $# < 1 )); then
	print_usage
    fi

    local basecmd="${1:-}"
    shift

    case "$basecmd" in
	n|new)
	    new "$@"
	    ;;
	e|edit)
	    edit "$@"
	    ;;
	j|journal)
	    journal "$@"
	    ;;
	q|query)
	    query "$@"
	    ;;
	p|pomo|pomodoro)
	    pomodoro "$@"
	    ;;
	s|sql)
	    sql "$@"
	    ;;
	b|board)
	    board "$@"
	    ;;
	t|tasks)
	    tasks "$@"
	    ;;
	*)
	    print_usage
    esac
}


main "$@"
